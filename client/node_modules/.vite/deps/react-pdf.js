import {
  dequal,
  require_warning
} from "./chunk-FGO52NSA.js";
import {
  require_pdf
} from "./chunk-2PUQJBHP.js";
import {
  require_prop_types
} from "./chunk-QPD4LXAH.js";
import {
  require_react
} from "./chunk-AHKXTZ64.js";
import {
  __toESM
} from "./chunk-BYPFWIQ6.js";

// node_modules/react-pdf/dist/esm/pdfjs.js
var pdfjsModule = __toESM(require_pdf(), 1);
var pdfjs = "default" in pdfjsModule ? pdfjsModule["default"] : pdfjsModule;
var pdfjs_default = pdfjs;

// node_modules/react-pdf/dist/esm/Document.js
var import_react4 = __toESM(require_react(), 1);
var import_prop_types2 = __toESM(require_prop_types(), 1);

// node_modules/make-event-props/dist/esm/index.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var clipboardEvents = ["onCopy", "onCut", "onPaste"];
var compositionEvents = [
  "onCompositionEnd",
  "onCompositionStart",
  "onCompositionUpdate"
];
var focusEvents = ["onFocus", "onBlur"];
var formEvents = ["onInput", "onInvalid", "onReset", "onSubmit"];
var imageEvents = ["onLoad", "onError"];
var keyboardEvents = ["onKeyDown", "onKeyPress", "onKeyUp"];
var mediaEvents = [
  "onAbort",
  "onCanPlay",
  "onCanPlayThrough",
  "onDurationChange",
  "onEmptied",
  "onEncrypted",
  "onEnded",
  "onError",
  "onLoadedData",
  "onLoadedMetadata",
  "onLoadStart",
  "onPause",
  "onPlay",
  "onPlaying",
  "onProgress",
  "onRateChange",
  "onSeeked",
  "onSeeking",
  "onStalled",
  "onSuspend",
  "onTimeUpdate",
  "onVolumeChange",
  "onWaiting"
];
var mouseEvents = [
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onMouseDown",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseOut",
  "onMouseOver",
  "onMouseUp"
];
var dragEvents = [
  "onDrag",
  "onDragEnd",
  "onDragEnter",
  "onDragExit",
  "onDragLeave",
  "onDragOver",
  "onDragStart",
  "onDrop"
];
var selectionEvents = ["onSelect"];
var touchEvents = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"];
var pointerEvents = [
  "onPointerDown",
  "onPointerMove",
  "onPointerUp",
  "onPointerCancel",
  "onGotPointerCapture",
  "onLostPointerCapture",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerOver",
  "onPointerOut"
];
var uiEvents = ["onScroll"];
var wheelEvents = ["onWheel"];
var animationEvents = [
  "onAnimationStart",
  "onAnimationEnd",
  "onAnimationIteration"
];
var transitionEvents = ["onTransitionEnd"];
var otherEvents = ["onToggle"];
var changeEvents = ["onChange"];
var allEvents = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], clipboardEvents, true), compositionEvents, true), focusEvents, true), formEvents, true), imageEvents, true), keyboardEvents, true), mediaEvents, true), mouseEvents, true), dragEvents, true), selectionEvents, true), touchEvents, true), pointerEvents, true), uiEvents, true), wheelEvents, true), animationEvents, true), transitionEvents, true), changeEvents, true), otherEvents, true);
function makeEventProps(props, getArgs) {
  var eventProps2 = {};
  allEvents.forEach(function(eventName) {
    var eventHandler = props[eventName];
    if (!eventHandler) {
      return;
    }
    if (getArgs) {
      eventProps2[eventName] = function(event) {
        return eventHandler(event, getArgs(eventName));
      };
    } else {
      eventProps2[eventName] = eventHandler;
    }
  });
  return eventProps2;
}

// node_modules/make-cancellable-promise/dist/esm/index.js
function makeCancellablePromise(promise) {
  var isCancelled = false;
  var wrappedPromise = new Promise(function(resolve, reject) {
    promise.then(function(value) {
      return !isCancelled && resolve(value);
    }).catch(function(error) {
      return !isCancelled && reject(error);
    });
  });
  return {
    promise: wrappedPromise,
    cancel: function() {
      isCancelled = true;
    }
  };
}

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e)
    n += e;
  else if ("object" == typeof e)
    if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++)
        e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else
      for (f in e)
        e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++)
    (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// node_modules/react-pdf/dist/esm/Document.js
var import_warning2 = __toESM(require_warning(), 1);

// node_modules/react-pdf/dist/esm/DocumentContext.js
var import_react = __toESM(require_react(), 1);
var DocumentContext_default = (0, import_react.createContext)(null);

// node_modules/react-pdf/dist/esm/Message.js
var import_react2 = __toESM(require_react(), 1);
function Message({ children, type }) {
  return import_react2.default.createElement("div", { className: `react-pdf__message react-pdf__message--${type}` }, children);
}

// node_modules/react-pdf/dist/esm/LinkService.js
var DEFAULT_LINK_REL = "noopener noreferrer nofollow";
var LinkService = class {
  constructor() {
    this.externalLinkEnabled = true;
    this.externalLinkRel = void 0;
    this.externalLinkTarget = void 0;
    this.isInPresentationMode = false;
    this.pdfDocument = void 0;
    this.pdfViewer = void 0;
  }
  setDocument(pdfDocument) {
    this.pdfDocument = pdfDocument;
  }
  setViewer(pdfViewer) {
    this.pdfViewer = pdfViewer;
  }
  setExternalLinkRel(externalLinkRel) {
    this.externalLinkRel = externalLinkRel;
  }
  setExternalLinkTarget(externalLinkTarget) {
    this.externalLinkTarget = externalLinkTarget;
  }
  setHistory() {
  }
  get pagesCount() {
    return this.pdfDocument ? this.pdfDocument.numPages : 0;
  }
  get page() {
    invariant(this.pdfViewer, "PDF viewer is not initialized.");
    return this.pdfViewer.currentPageNumber || 0;
  }
  set page(value) {
    invariant(this.pdfViewer, "PDF viewer is not initialized.");
    this.pdfViewer.currentPageNumber = value;
  }
  // eslint-disable-next-line @typescript-eslint/class-literal-property-style
  get rotation() {
    return 0;
  }
  set rotation(value) {
  }
  goToDestination(dest) {
    return new Promise((resolve) => {
      invariant(this.pdfDocument, "PDF document not loaded.");
      invariant(dest, "Destination is not specified.");
      if (typeof dest === "string") {
        this.pdfDocument.getDestination(dest).then(resolve);
      } else if (Array.isArray(dest)) {
        resolve(dest);
      } else {
        dest.then(resolve);
      }
    }).then((explicitDest) => {
      invariant(Array.isArray(explicitDest), `"${explicitDest}" is not a valid destination array.`);
      const destRef = explicitDest[0];
      new Promise((resolve) => {
        invariant(this.pdfDocument, "PDF document not loaded.");
        if (destRef instanceof Object) {
          this.pdfDocument.getPageIndex(destRef).then((pageIndex) => {
            resolve(pageIndex);
          }).catch(() => {
            invariant(false, `"${destRef}" is not a valid page reference.`);
          });
        } else if (typeof destRef === "number") {
          resolve(destRef);
        } else {
          invariant(false, `"${destRef}" is not a valid destination reference.`);
        }
      }).then((pageIndex) => {
        const pageNumber = pageIndex + 1;
        invariant(this.pdfViewer, "PDF viewer is not initialized.");
        invariant(pageNumber >= 1 && pageNumber <= this.pagesCount, `"${pageNumber}" is not a valid page number.`);
        this.pdfViewer.scrollPageIntoView({
          dest: explicitDest,
          pageIndex,
          pageNumber
        });
      });
    });
  }
  navigateTo(dest) {
    this.goToDestination(dest);
  }
  goToPage(pageNumber) {
    const pageIndex = pageNumber - 1;
    invariant(this.pdfViewer, "PDF viewer is not initialized.");
    invariant(pageNumber >= 1 && pageNumber <= this.pagesCount, `"${pageNumber}" is not a valid page number.`);
    this.pdfViewer.scrollPageIntoView({
      pageIndex,
      pageNumber
    });
  }
  addLinkAttributes(link, url, newWindow) {
    link.href = url;
    link.rel = this.externalLinkRel || DEFAULT_LINK_REL;
    link.target = newWindow ? "_blank" : this.externalLinkTarget || "";
  }
  getDestinationHash() {
    return "#";
  }
  getAnchorUrl() {
    return "#";
  }
  setHash() {
  }
  executeNamedAction() {
  }
  cachePageRef() {
  }
  isPageVisible() {
    return true;
  }
  isPageCached() {
    return true;
  }
  executeSetOCGState() {
  }
};

// node_modules/react-pdf/dist/esm/PasswordResponses.js
var PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
var PasswordResponses_default = PasswordResponses;

// node_modules/react-pdf/dist/esm/shared/utils.js
var import_warning = __toESM(require_warning(), 1);
var isBrowser = typeof document !== "undefined";
var isLocalFileSystem = isBrowser && window.location.protocol === "file:";
function isDefined(variable) {
  return typeof variable !== "undefined";
}
function isProvided(variable) {
  return isDefined(variable) && variable !== null;
}
function isString(variable) {
  return typeof variable === "string";
}
function isArrayBuffer(variable) {
  return variable instanceof ArrayBuffer;
}
function isBlob(variable) {
  invariant(isBrowser, "isBlob can only be used in a browser environment");
  return variable instanceof Blob;
}
function isDataURI(variable) {
  return isString(variable) && /^data:/.test(variable);
}
function dataURItoByteString(dataURI) {
  invariant(isDataURI(dataURI), "Invalid data URI.");
  const [headersString = "", dataString = ""] = dataURI.split(",");
  const headers = headersString.split(";");
  if (headers.indexOf("base64") !== -1) {
    return atob(dataString);
  }
  return unescape(dataString);
}
function getDevicePixelRatio() {
  return isBrowser && window.devicePixelRatio || 1;
}
var allowFileAccessFromFilesTip = "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.";
function displayCORSWarning() {
  (0, import_warning.default)(!isLocalFileSystem, `Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);
}
function displayWorkerWarning() {
  (0, import_warning.default)(!isLocalFileSystem, `Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`);
}
function cancelRunningTask(runningTask) {
  if (runningTask && runningTask.cancel)
    runningTask.cancel();
}
function makePageCallback(page, scale) {
  Object.defineProperty(page, "width", {
    get() {
      return this.view[2] * scale;
    },
    configurable: true
  });
  Object.defineProperty(page, "height", {
    get() {
      return this.view[3] * scale;
    },
    configurable: true
  });
  Object.defineProperty(page, "originalWidth", {
    get() {
      return this.view[2];
    },
    configurable: true
  });
  Object.defineProperty(page, "originalHeight", {
    get() {
      return this.view[3];
    },
    configurable: true
  });
  return page;
}
function isCancelException(error) {
  return error.name === "RenderingCancelledException";
}
function loadFromFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      if (!reader.result) {
        return reject(new Error("Error while reading a file."));
      }
      resolve(reader.result);
    };
    reader.onerror = (event) => {
      if (!event.target) {
        return reject(new Error("Error while reading a file."));
      }
      const { error } = event.target;
      if (!error) {
        return reject(new Error("Error while reading a file."));
      }
      switch (error.code) {
        case error.NOT_FOUND_ERR:
          return reject(new Error("Error while reading a file: File not found."));
        case error.SECURITY_ERR:
          return reject(new Error("Error while reading a file: Security error."));
        case error.ABORT_ERR:
          return reject(new Error("Error while reading a file: Aborted."));
        default:
          return reject(new Error("Error while reading a file."));
      }
    };
    reader.readAsArrayBuffer(file);
  });
}

// node_modules/react-pdf/dist/esm/shared/hooks/useResolver.js
var import_react3 = __toESM(require_react(), 1);
function reducer(state, action) {
  switch (action.type) {
    case "RESOLVE":
      return { value: action.value, error: void 0 };
    case "REJECT":
      return { value: false, error: action.error };
    case "RESET":
      return { value: void 0, error: void 0 };
    default:
      return state;
  }
}
function useResolver() {
  return (0, import_react3.useReducer)(reducer, { value: void 0, error: void 0 });
}

// node_modules/react-pdf/dist/esm/shared/propTypes.js
var import_prop_types = __toESM(require_prop_types(), 1);
var { PDFDataRangeTransport } = pdfjs_default;
var eventProps = (() => {
  const result = {};
  allEvents.forEach((eventName) => {
    result[eventName] = import_prop_types.default.func;
  });
  return result;
})();
var isTypedArray = import_prop_types.default.oneOfType([
  import_prop_types.default.instanceOf(Int8Array),
  import_prop_types.default.instanceOf(Uint8Array),
  import_prop_types.default.instanceOf(Uint8ClampedArray),
  import_prop_types.default.instanceOf(Int16Array),
  import_prop_types.default.instanceOf(Uint16Array),
  import_prop_types.default.instanceOf(Int32Array),
  import_prop_types.default.instanceOf(Uint32Array),
  import_prop_types.default.instanceOf(Float32Array),
  import_prop_types.default.instanceOf(Float64Array)
]);
var fileTypes = [
  import_prop_types.default.string,
  import_prop_types.default.instanceOf(ArrayBuffer),
  import_prop_types.default.shape({
    data: import_prop_types.default.oneOfType([
      import_prop_types.default.string,
      import_prop_types.default.instanceOf(ArrayBuffer),
      import_prop_types.default.arrayOf(import_prop_types.default.number.isRequired),
      isTypedArray
    ]).isRequired
  }),
  import_prop_types.default.shape({
    range: import_prop_types.default.instanceOf(PDFDataRangeTransport).isRequired
  }),
  import_prop_types.default.shape({
    url: import_prop_types.default.string.isRequired
  })
];
if (typeof Blob !== "undefined") {
  fileTypes.push(import_prop_types.default.instanceOf(Blob));
}
var isClassName = import_prop_types.default.oneOfType([
  import_prop_types.default.string,
  import_prop_types.default.arrayOf(import_prop_types.default.string)
]);
var isFile = import_prop_types.default.oneOfType(fileTypes);
var isLinkService = import_prop_types.default.instanceOf(LinkService);
var isLinkTarget = import_prop_types.default.oneOf(["_self", "_blank", "_parent", "_top"]);
var isPage = import_prop_types.default.shape({
  commonObjs: import_prop_types.default.shape({}).isRequired,
  getAnnotations: import_prop_types.default.func.isRequired,
  getTextContent: import_prop_types.default.func.isRequired,
  getViewport: import_prop_types.default.func.isRequired,
  render: import_prop_types.default.func.isRequired
});
var isPageIndex = function isPageIndex2(props, propName, componentName) {
  const { [propName]: pageIndex, pageNumber, pdf } = props;
  if (!isDefined(pdf)) {
    return null;
  }
  if (isDefined(pageIndex)) {
    if (typeof pageIndex !== "number") {
      return new Error(`\`${propName}\` of type \`${typeof pageIndex}\` supplied to \`${componentName}\`, expected \`number\`.`);
    }
    if (pageIndex < 0) {
      return new Error(`Expected \`${propName}\` to be greater or equal to 0.`);
    }
    const { numPages } = pdf;
    if (pageIndex + 1 > numPages) {
      return new Error(`Expected \`${propName}\` to be less or equal to ${numPages - 1}.`);
    }
  } else if (!isDefined(pageNumber)) {
    return new Error(`\`${propName}\` not supplied. Either pageIndex or pageNumber must be supplied to \`${componentName}\`.`);
  }
  return null;
};
var isPageNumber = function isPageNumber2(props, propName, componentName) {
  const { [propName]: pageNumber, pageIndex, pdf } = props;
  if (!isDefined(pdf)) {
    return null;
  }
  if (isDefined(pageNumber)) {
    if (typeof pageNumber !== "number") {
      return new Error(`\`${propName}\` of type \`${typeof pageNumber}\` supplied to \`${componentName}\`, expected \`number\`.`);
    }
    if (pageNumber < 1) {
      return new Error(`Expected \`${propName}\` to be greater or equal to 1.`);
    }
    const { numPages } = pdf;
    if (pageNumber > numPages) {
      return new Error(`Expected \`${propName}\` to be less or equal to ${numPages}.`);
    }
  } else if (!isDefined(pageIndex)) {
    return new Error(`\`${propName}\` not supplied. Either pageIndex or pageNumber must be supplied to \`${componentName}\`.`);
  }
  return null;
};
var isPdf = import_prop_types.default.oneOfType([
  // Ideally, this would be `PropTypes.instanceOf(PDFDocumentProxy)`, but it can't be imported.
  import_prop_types.default.any,
  import_prop_types.default.oneOf([false])
]);
var isRef = import_prop_types.default.oneOfType([
  import_prop_types.default.func,
  import_prop_types.default.exact({
    current: import_prop_types.default.any
  })
]);
var isRenderMode = import_prop_types.default.oneOf(["canvas", "custom", "none", "svg"]);
var isRotate = import_prop_types.default.oneOf([0, 90, 180, 270]);

// node_modules/react-pdf/dist/esm/Document.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var { PDFDataRangeTransport: PDFDataRangeTransport2 } = pdfjs_default;
var defaultOnPassword = (callback, reason) => {
  switch (reason) {
    case PasswordResponses_default.NEED_PASSWORD: {
      const password = prompt("Enter the password to open this PDF file.");
      callback(password);
      break;
    }
    case PasswordResponses_default.INCORRECT_PASSWORD: {
      const password = prompt("Invalid password. Please try again.");
      callback(password);
      break;
    }
    default:
  }
};
function isParameterObject(file) {
  return typeof file === "object" && file !== null && ("data" in file || "range" in file || "url" in file);
}
var Document = (0, import_react4.forwardRef)(function Document2(_a, ref) {
  var { children, className, error = "Failed to load PDF file.", externalLinkRel, externalLinkTarget, file, inputRef, imageResourcesPath, loading = "Loading PDFâ€¦", noData = "No PDF file specified.", onItemClick, onLoadError: onLoadErrorProps, onLoadProgress, onLoadSuccess: onLoadSuccessProps, onPassword = defaultOnPassword, onSourceError: onSourceErrorProps, onSourceSuccess: onSourceSuccessProps, options, renderMode, rotate } = _a, otherProps = __rest(_a, ["children", "className", "error", "externalLinkRel", "externalLinkTarget", "file", "inputRef", "imageResourcesPath", "loading", "noData", "onItemClick", "onLoadError", "onLoadProgress", "onLoadSuccess", "onPassword", "onSourceError", "onSourceSuccess", "options", "renderMode", "rotate"]);
  const [sourceState, sourceDispatch] = useResolver();
  const { value: source, error: sourceError } = sourceState;
  const [pdfState, pdfDispatch] = useResolver();
  const { value: pdf, error: pdfError } = pdfState;
  const linkService = (0, import_react4.useRef)(new LinkService());
  const pages = (0, import_react4.useRef)([]);
  const prevFile = (0, import_react4.useRef)();
  const prevOptions = (0, import_react4.useRef)();
  (0, import_react4.useEffect)(() => {
    if (file && file !== prevFile.current && isParameterObject(file)) {
      (0, import_warning2.default)(!dequal(file, prevFile.current), `File prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "file" prop.`);
      prevFile.current = file;
    }
  }, [file]);
  (0, import_react4.useEffect)(() => {
    if (options && options !== prevOptions.current) {
      (0, import_warning2.default)(!dequal(options, prevOptions.current), `Options prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "options" prop.`);
      prevOptions.current = options;
    }
  }, [options]);
  const viewer = (0, import_react4.useRef)({
    // Handling jumping to internal links target
    scrollPageIntoView: (args) => {
      const { dest, pageNumber, pageIndex = pageNumber - 1 } = args;
      if (onItemClick) {
        onItemClick({ dest, pageIndex, pageNumber });
        return;
      }
      const page = pages.current[pageIndex];
      if (page) {
        page.scrollIntoView();
        return;
      }
      (0, import_warning2.default)(false, `An internal link leading to page ${pageNumber} was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.`);
    }
  });
  (0, import_react4.useImperativeHandle)(ref, () => ({
    linkService,
    pages,
    viewer
  }), []);
  function onSourceSuccess() {
    if (onSourceSuccessProps) {
      onSourceSuccessProps();
    }
  }
  function onSourceError() {
    if (!sourceError) {
      return;
    }
    (0, import_warning2.default)(false, sourceError.toString());
    if (onSourceErrorProps) {
      onSourceErrorProps(sourceError);
    }
  }
  function resetSource() {
    sourceDispatch({ type: "RESET" });
  }
  (0, import_react4.useEffect)(resetSource, [file, sourceDispatch]);
  const findDocumentSource = (0, import_react4.useCallback)(() => __awaiter(this, void 0, void 0, function* () {
    if (!file) {
      return null;
    }
    if (typeof file === "string") {
      if (isDataURI(file)) {
        const fileByteString = dataURItoByteString(file);
        return { data: fileByteString };
      }
      displayCORSWarning();
      return { url: file };
    }
    if (file instanceof PDFDataRangeTransport2) {
      return { range: file };
    }
    if (isArrayBuffer(file)) {
      return { data: file };
    }
    if (isBrowser) {
      if (isBlob(file)) {
        const data = yield loadFromFile(file);
        return { data };
      }
    }
    invariant(typeof file === "object", "Invalid parameter in file, need either Uint8Array, string or a parameter object");
    invariant(isParameterObject(file), "Invalid parameter object: need either .data, .range or .url");
    if ("url" in file && typeof file.url === "string") {
      if (isDataURI(file.url)) {
        const { url } = file, otherParams = __rest(file, ["url"]);
        const fileByteString = dataURItoByteString(url);
        return Object.assign({ data: fileByteString }, otherParams);
      }
      displayCORSWarning();
    }
    return file;
  }), [file]);
  (0, import_react4.useEffect)(() => {
    const cancellable = makeCancellablePromise(findDocumentSource());
    cancellable.promise.then((nextSource) => {
      sourceDispatch({ type: "RESOLVE", value: nextSource });
    }).catch((error2) => {
      sourceDispatch({ type: "REJECT", error: error2 });
    });
    return () => {
      cancelRunningTask(cancellable);
    };
  }, [findDocumentSource, sourceDispatch]);
  (0, import_react4.useEffect)(
    () => {
      if (typeof source === "undefined") {
        return;
      }
      if (source === false) {
        onSourceError();
        return;
      }
      onSourceSuccess();
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [source]
  );
  function onLoadSuccess() {
    if (!pdf) {
      return;
    }
    if (onLoadSuccessProps) {
      onLoadSuccessProps(pdf);
    }
    pages.current = new Array(pdf.numPages);
    linkService.current.setDocument(pdf);
  }
  function onLoadError() {
    if (!pdfError) {
      return;
    }
    (0, import_warning2.default)(false, pdfError.toString());
    if (onLoadErrorProps) {
      onLoadErrorProps(pdfError);
    }
  }
  function resetDocument() {
    pdfDispatch({ type: "RESET" });
  }
  (0, import_react4.useEffect)(resetDocument, [pdfDispatch, source]);
  function loadDocument() {
    if (!source) {
      return;
    }
    const optionsWithModifiedIsEvalSupported = Object.assign(Object.assign({}, options), { isEvalSupported: false });
    const documentInitParams = Object.assign(Object.assign({}, source), optionsWithModifiedIsEvalSupported);
    const destroyable = pdfjs_default.getDocument(documentInitParams);
    if (onLoadProgress) {
      destroyable.onProgress = onLoadProgress;
    }
    if (onPassword) {
      destroyable.onPassword = onPassword;
    }
    const loadingTask = destroyable;
    loadingTask.promise.then((nextPdf) => {
      pdfDispatch({ type: "RESOLVE", value: nextPdf });
    }).catch((error2) => {
      if (loadingTask.destroyed) {
        return;
      }
      pdfDispatch({ type: "REJECT", error: error2 });
    });
    return () => {
      loadingTask.destroy();
    };
  }
  (0, import_react4.useEffect)(
    loadDocument,
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [options, pdfDispatch, source]
  );
  (0, import_react4.useEffect)(
    () => {
      if (typeof pdf === "undefined") {
        return;
      }
      if (pdf === false) {
        onLoadError();
        return;
      }
      onLoadSuccess();
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [pdf]
  );
  function setupLinkService() {
    linkService.current.setViewer(viewer.current);
    linkService.current.setExternalLinkRel(externalLinkRel);
    linkService.current.setExternalLinkTarget(externalLinkTarget);
  }
  (0, import_react4.useEffect)(setupLinkService, [externalLinkRel, externalLinkTarget]);
  function registerPage(pageIndex, ref2) {
    pages.current[pageIndex] = ref2;
  }
  function unregisterPage(pageIndex) {
    delete pages.current[pageIndex];
  }
  const childContext = (0, import_react4.useMemo)(() => ({
    imageResourcesPath,
    linkService: linkService.current,
    onItemClick,
    pdf,
    registerPage,
    renderMode,
    rotate,
    unregisterPage
  }), [imageResourcesPath, onItemClick, pdf, renderMode, rotate]);
  const eventProps2 = (0, import_react4.useMemo)(() => makeEventProps(otherProps, () => pdf), [otherProps, pdf]);
  function renderChildren() {
    return import_react4.default.createElement(DocumentContext_default.Provider, { value: childContext }, children);
  }
  function renderContent() {
    if (!file) {
      return import_react4.default.createElement(Message, { type: "no-data" }, typeof noData === "function" ? noData() : noData);
    }
    if (pdf === void 0 || pdf === null) {
      return import_react4.default.createElement(Message, { type: "loading" }, typeof loading === "function" ? loading() : loading);
    }
    if (pdf === false) {
      return import_react4.default.createElement(Message, { type: "error" }, typeof error === "function" ? error() : error);
    }
    return renderChildren();
  }
  return import_react4.default.createElement("div", Object.assign({ className: clsx_default("react-pdf__Document", className), ref: inputRef, style: {
    ["--scale-factor"]: "1"
  } }, eventProps2), renderContent());
});
var isFunctionOrNode = import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.node]);
Document.propTypes = Object.assign(Object.assign({}, eventProps), { children: import_prop_types2.default.node, className: isClassName, error: isFunctionOrNode, externalLinkRel: import_prop_types2.default.string, externalLinkTarget: import_prop_types2.default.oneOf(["_self", "_blank", "_parent", "_top"]), file: isFile, imageResourcesPath: import_prop_types2.default.string, inputRef: isRef, loading: isFunctionOrNode, noData: isFunctionOrNode, onItemClick: import_prop_types2.default.func, onLoadError: import_prop_types2.default.func, onLoadProgress: import_prop_types2.default.func, onLoadSuccess: import_prop_types2.default.func, onPassword: import_prop_types2.default.func, onSourceError: import_prop_types2.default.func, onSourceSuccess: import_prop_types2.default.func, options: import_prop_types2.default.shape({
  canvasFactory: import_prop_types2.default.any,
  canvasMaxAreaInBytes: import_prop_types2.default.number,
  cMapPacked: import_prop_types2.default.bool,
  CMapReaderFactory: import_prop_types2.default.any,
  cMapUrl: import_prop_types2.default.string,
  disableAutoFetch: import_prop_types2.default.bool,
  disableFontFace: import_prop_types2.default.bool,
  disableRange: import_prop_types2.default.bool,
  disableStream: import_prop_types2.default.bool,
  docBaseUrl: import_prop_types2.default.string,
  enableXfa: import_prop_types2.default.bool,
  filterFactory: import_prop_types2.default.any,
  fontExtraProperties: import_prop_types2.default.bool,
  httpHeaders: import_prop_types2.default.object,
  isEvalSupported: import_prop_types2.default.bool,
  isOffscreenCanvasSupported: import_prop_types2.default.bool,
  length: import_prop_types2.default.number,
  maxImageSize: import_prop_types2.default.number,
  ownerDocument: import_prop_types2.default.any,
  password: import_prop_types2.default.string,
  pdfBug: import_prop_types2.default.bool,
  rangeChunkSize: import_prop_types2.default.number,
  StandardFontDataFactory: import_prop_types2.default.any,
  standardFontDataUrl: import_prop_types2.default.string,
  stopAtErrors: import_prop_types2.default.bool,
  useSystemFonts: import_prop_types2.default.bool,
  useWorkerFetch: import_prop_types2.default.bool,
  verbosity: import_prop_types2.default.number,
  withCredentials: import_prop_types2.default.bool,
  worker: import_prop_types2.default.any
}), rotate: import_prop_types2.default.number });
var Document_default = Document;

// node_modules/react-pdf/dist/esm/Outline.js
var import_react10 = __toESM(require_react(), 1);
var import_prop_types3 = __toESM(require_prop_types(), 1);
var import_warning3 = __toESM(require_warning(), 1);

// node_modules/react-pdf/dist/esm/OutlineContext.js
var import_react5 = __toESM(require_react(), 1);
var OutlineContext_default = (0, import_react5.createContext)(null);

// node_modules/react-pdf/dist/esm/OutlineItem.js
var import_react9 = __toESM(require_react(), 1);

// node_modules/react-pdf/dist/esm/Ref.js
var Ref = class {
  constructor({ num, gen }) {
    this.num = num;
    this.gen = gen;
  }
  toString() {
    let str = `${this.num}R`;
    if (this.gen !== 0) {
      str += this.gen;
    }
    return str;
  }
};

// node_modules/react-pdf/dist/esm/shared/hooks/useCachedValue.js
var import_react6 = __toESM(require_react(), 1);
function useCachedValue(getter) {
  const ref = (0, import_react6.useRef)();
  const currentValue = ref.current;
  if (isDefined(currentValue)) {
    return () => currentValue;
  }
  return () => {
    const value = getter();
    ref.current = value;
    return value;
  };
}

// node_modules/react-pdf/dist/esm/shared/hooks/useDocumentContext.js
var import_react7 = __toESM(require_react(), 1);
function useDocumentContext() {
  return (0, import_react7.useContext)(DocumentContext_default);
}

// node_modules/react-pdf/dist/esm/shared/hooks/useOutlineContext.js
var import_react8 = __toESM(require_react(), 1);
function useOutlineContext() {
  return (0, import_react8.useContext)(OutlineContext_default);
}

// node_modules/react-pdf/dist/esm/OutlineItem.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
function OutlineItem(props) {
  const documentContext = useDocumentContext();
  const outlineContext = useOutlineContext();
  invariant(outlineContext, "Unable to find Outline context.");
  const mergedProps = Object.assign(Object.assign(Object.assign({}, documentContext), outlineContext), props);
  const { item, linkService, onItemClick, pdf } = mergedProps, otherProps = __rest2(mergedProps, ["item", "linkService", "onItemClick", "pdf"]);
  invariant(pdf, "Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.");
  const getDestination = useCachedValue(() => {
    if (typeof item.dest === "string") {
      return pdf.getDestination(item.dest);
    }
    return item.dest;
  });
  const getPageIndex = useCachedValue(() => __awaiter2(this, void 0, void 0, function* () {
    const destination = yield getDestination();
    if (!destination) {
      throw new Error("Destination not found.");
    }
    const [ref] = destination;
    return pdf.getPageIndex(new Ref(ref));
  }));
  const getPageNumber = useCachedValue(() => __awaiter2(this, void 0, void 0, function* () {
    const pageIndex = yield getPageIndex();
    return pageIndex + 1;
  }));
  function onClick(event) {
    event.preventDefault();
    invariant(onItemClick || linkService, "Either onItemClick callback or linkService must be defined in order to navigate to an outline item.");
    if (onItemClick) {
      Promise.all([getDestination(), getPageIndex(), getPageNumber()]).then(([dest, pageIndex, pageNumber]) => {
        onItemClick({
          dest,
          pageIndex,
          pageNumber
        });
      });
    } else if (linkService) {
      linkService.goToDestination(item.dest);
    }
  }
  function renderSubitems() {
    if (!item.items || !item.items.length) {
      return null;
    }
    const { items: subitems } = item;
    return import_react9.default.createElement("ul", null, subitems.map((subitem, subitemIndex) => import_react9.default.createElement(OutlineItem, Object.assign({ key: typeof subitem.dest === "string" ? subitem.dest : subitemIndex, item: subitem, pdf }, otherProps))));
  }
  return import_react9.default.createElement(
    "li",
    null,
    import_react9.default.createElement("a", { href: "#", onClick }, item.title),
    renderSubitems()
  );
}

// node_modules/react-pdf/dist/esm/Outline.js
var __rest3 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Outline = function Outline2(props) {
  const documentContext = useDocumentContext();
  const mergedProps = Object.assign(Object.assign({}, documentContext), props);
  const { className, inputRef, onItemClick, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, pdf } = mergedProps, otherProps = __rest3(mergedProps, ["className", "inputRef", "onItemClick", "onLoadError", "onLoadSuccess", "pdf"]);
  invariant(pdf, "Attempted to load an outline, but no document was specified. Wrap <Outline /> in a <Document /> or pass explicit `pdf` prop.");
  const [outlineState, outlineDispatch] = useResolver();
  const { value: outline, error: outlineError } = outlineState;
  function onLoadSuccess() {
    if (typeof outline === "undefined" || outline === false) {
      return;
    }
    if (onLoadSuccessProps) {
      onLoadSuccessProps(outline);
    }
  }
  function onLoadError() {
    if (!outlineError) {
      return;
    }
    (0, import_warning3.default)(false, outlineError.toString());
    if (onLoadErrorProps) {
      onLoadErrorProps(outlineError);
    }
  }
  function resetOutline() {
    outlineDispatch({ type: "RESET" });
  }
  (0, import_react10.useEffect)(resetOutline, [outlineDispatch, pdf]);
  function loadOutline() {
    if (!pdf) {
      return;
    }
    const cancellable = makeCancellablePromise(pdf.getOutline());
    const runningTask = cancellable;
    cancellable.promise.then((nextOutline) => {
      outlineDispatch({ type: "RESOLVE", value: nextOutline });
    }).catch((error) => {
      outlineDispatch({ type: "REJECT", error });
    });
    return () => cancelRunningTask(runningTask);
  }
  (0, import_react10.useEffect)(loadOutline, [outlineDispatch, pdf]);
  (0, import_react10.useEffect)(
    () => {
      if (outline === void 0) {
        return;
      }
      if (outline === false) {
        onLoadError();
        return;
      }
      onLoadSuccess();
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [outline]
  );
  const childContext = (0, import_react10.useMemo)(() => ({
    onItemClick
  }), [onItemClick]);
  const eventProps2 = (0, import_react10.useMemo)(() => makeEventProps(otherProps, () => outline), [otherProps, outline]);
  if (!outline) {
    return null;
  }
  function renderOutline() {
    if (!outline) {
      return null;
    }
    return import_react10.default.createElement("ul", null, outline.map((item, itemIndex) => import_react10.default.createElement(OutlineItem, { key: typeof item.dest === "string" ? item.dest : itemIndex, item, pdf })));
  }
  return import_react10.default.createElement(
    "div",
    Object.assign({ className: clsx_default("react-pdf__Outline", className), ref: inputRef }, eventProps2),
    import_react10.default.createElement(OutlineContext_default.Provider, { value: childContext }, renderOutline())
  );
};
Outline.propTypes = Object.assign(Object.assign({}, eventProps), { className: isClassName, inputRef: isRef, onItemClick: import_prop_types3.default.func, onLoadError: import_prop_types3.default.func, onLoadSuccess: import_prop_types3.default.func, pdf: isPdf });
var Outline_default = Outline;

// node_modules/react-pdf/dist/esm/Page.js
var import_react19 = __toESM(require_react(), 1);
var import_prop_types4 = __toESM(require_prop_types(), 1);

// node_modules/merge-refs/dist/esm/index.js
function mergeRefs() {
  var inputRefs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputRefs[_i] = arguments[_i];
  }
  var filteredInputRefs = inputRefs.filter(Boolean);
  if (filteredInputRefs.length <= 1) {
    var firstRef = filteredInputRefs[0];
    return firstRef || null;
  }
  return function mergedRefs(ref) {
    filteredInputRefs.forEach(function(inputRef) {
      if (typeof inputRef === "function") {
        inputRef(ref);
      } else if (inputRef) {
        inputRef.current = ref;
      }
    });
  };
}

// node_modules/react-pdf/dist/esm/Page.js
var import_warning9 = __toESM(require_warning(), 1);

// node_modules/react-pdf/dist/esm/PageContext.js
var import_react11 = __toESM(require_react(), 1);
var PageContext_default = (0, import_react11.createContext)(null);

// node_modules/react-pdf/dist/esm/Page/PageCanvas.js
var import_react15 = __toESM(require_react(), 1);
var import_warning5 = __toESM(require_warning(), 1);

// node_modules/react-pdf/dist/esm/StructTree.js
var import_react14 = __toESM(require_react(), 1);
var import_warning4 = __toESM(require_warning(), 1);

// node_modules/react-pdf/dist/esm/StructTreeItem.js
var import_react12 = __toESM(require_react(), 1);

// node_modules/react-pdf/dist/esm/shared/constants.js
var PDF_ROLE_TO_HTML_ROLE = {
  // Document level structure types
  Document: null,
  // There's a "document" role, but it doesn't make sense here.
  DocumentFragment: null,
  // Grouping level structure types
  Part: "group",
  Sect: "group",
  // XXX: There's a "section" role, but it's abstract.
  Div: "group",
  Aside: "note",
  NonStruct: "none",
  // Block level structure types
  P: null,
  // H<n>,
  H: "heading",
  Title: null,
  FENote: "note",
  // Sub-block level structure type
  Sub: "group",
  // General inline level structure types
  Lbl: null,
  Span: null,
  Em: null,
  Strong: null,
  Link: "link",
  Annot: "note",
  Form: "form",
  // Ruby and Warichu structure types
  Ruby: null,
  RB: null,
  RT: null,
  RP: null,
  Warichu: null,
  WT: null,
  WP: null,
  // List standard structure types
  L: "list",
  LI: "listitem",
  LBody: null,
  // Table standard structure types
  Table: "table",
  TR: "row",
  TH: "columnheader",
  TD: "cell",
  THead: "columnheader",
  TBody: null,
  TFoot: null,
  // Standard structure type Caption
  Caption: null,
  // Standard structure type Figure
  Figure: "figure",
  // Standard structure type Formula
  Formula: null,
  // standard structure type Artifact
  Artifact: null
};
var HEADING_PATTERN = /^H(\d+)$/;

// node_modules/react-pdf/dist/esm/shared/structTreeUtils.js
function isPdfRole(role) {
  return role in PDF_ROLE_TO_HTML_ROLE;
}
function isStructTreeNode(node) {
  return "children" in node;
}
function isStructTreeNodeWithOnlyContentChild(node) {
  if (!isStructTreeNode(node)) {
    return false;
  }
  return node.children.length === 1 && 0 in node.children && "id" in node.children[0];
}
function getRoleAttributes(node) {
  const attributes = {};
  if (isStructTreeNode(node)) {
    const { role } = node;
    const matches = role.match(HEADING_PATTERN);
    if (matches) {
      attributes.role = "heading";
      attributes["aria-level"] = Number(matches[1]);
    } else if (isPdfRole(role)) {
      const htmlRole = PDF_ROLE_TO_HTML_ROLE[role];
      if (htmlRole) {
        attributes.role = htmlRole;
      }
    }
  }
  return attributes;
}
function getBaseAttributes(node) {
  const attributes = {};
  if (isStructTreeNode(node)) {
    if (node.alt !== void 0) {
      attributes["aria-label"] = node.alt;
    }
    if (node.lang !== void 0) {
      attributes.lang = node.lang;
    }
    if (isStructTreeNodeWithOnlyContentChild(node)) {
      const [child] = node.children;
      if (child) {
        const childAttributes = getBaseAttributes(child);
        return Object.assign(Object.assign({}, attributes), childAttributes);
      }
    }
  } else {
    if ("id" in node) {
      attributes["aria-owns"] = node.id;
    }
  }
  return attributes;
}
function getAttributes(node) {
  if (!node) {
    return null;
  }
  return Object.assign(Object.assign({}, getRoleAttributes(node)), getBaseAttributes(node));
}

// node_modules/react-pdf/dist/esm/StructTreeItem.js
function StructTreeItem({ className, node }) {
  const attributes = (0, import_react12.useMemo)(() => getAttributes(node), [node]);
  const children = (0, import_react12.useMemo)(() => {
    if (!isStructTreeNode(node)) {
      return null;
    }
    if (isStructTreeNodeWithOnlyContentChild(node)) {
      return null;
    }
    return node.children.map((child, index) => {
      return (
        // eslint-disable-next-line react/no-array-index-key
        import_react12.default.createElement(StructTreeItem, { key: index, node: child })
      );
    });
  }, [node]);
  return import_react12.default.createElement("span", Object.assign({ className }, attributes), children);
}

// node_modules/react-pdf/dist/esm/shared/hooks/usePageContext.js
var import_react13 = __toESM(require_react(), 1);
function usePageContext() {
  return (0, import_react13.useContext)(PageContext_default);
}

// node_modules/react-pdf/dist/esm/StructTree.js
function StructTree() {
  const pageContext = usePageContext();
  invariant(pageContext, "Unable to find Page context.");
  const { onGetStructTreeError: onGetStructTreeErrorProps, onGetStructTreeSuccess: onGetStructTreeSuccessProps } = pageContext;
  const [structTreeState, structTreeDispatch] = useResolver();
  const { value: structTree, error: structTreeError } = structTreeState;
  const { customTextRenderer, page } = pageContext;
  function onLoadSuccess() {
    if (!structTree) {
      return;
    }
    if (onGetStructTreeSuccessProps) {
      onGetStructTreeSuccessProps(structTree);
    }
  }
  function onLoadError() {
    if (!structTreeError) {
      return;
    }
    (0, import_warning4.default)(false, structTreeError.toString());
    if (onGetStructTreeErrorProps) {
      onGetStructTreeErrorProps(structTreeError);
    }
  }
  function resetAnnotations() {
    structTreeDispatch({ type: "RESET" });
  }
  (0, import_react14.useEffect)(resetAnnotations, [structTreeDispatch, page]);
  function loadStructTree() {
    if (customTextRenderer) {
      return;
    }
    if (!page) {
      return;
    }
    const cancellable = makeCancellablePromise(page.getStructTree());
    const runningTask = cancellable;
    cancellable.promise.then((nextStructTree) => {
      structTreeDispatch({ type: "RESOLVE", value: nextStructTree });
    }).catch((error) => {
      structTreeDispatch({ type: "REJECT", error });
    });
    return () => cancelRunningTask(runningTask);
  }
  (0, import_react14.useEffect)(loadStructTree, [customTextRenderer, page, structTreeDispatch]);
  (0, import_react14.useEffect)(
    () => {
      if (structTree === void 0) {
        return;
      }
      if (structTree === false) {
        onLoadError();
        return;
      }
      onLoadSuccess();
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [structTree]
  );
  if (!structTree) {
    return null;
  }
  return import_react14.default.createElement(StructTreeItem, { className: "react-pdf__Page__structTree structTree", node: structTree });
}

// node_modules/react-pdf/dist/esm/Page/PageCanvas.js
var ANNOTATION_MODE = pdfjs_default.AnnotationMode;
function PageCanvas(props) {
  const pageContext = usePageContext();
  invariant(pageContext, "Unable to find Page context.");
  const mergedProps = Object.assign(Object.assign({}, pageContext), props);
  const { _className, canvasBackground, devicePixelRatio = getDevicePixelRatio(), onRenderError: onRenderErrorProps, onRenderSuccess: onRenderSuccessProps, page, renderForms, renderTextLayer, rotate, scale } = mergedProps;
  const { canvasRef } = props;
  invariant(page, "Attempted to render page canvas, but no page was specified.");
  const canvasElement = (0, import_react15.useRef)(null);
  function onRenderSuccess() {
    if (!page) {
      return;
    }
    if (onRenderSuccessProps) {
      onRenderSuccessProps(makePageCallback(page, scale));
    }
  }
  function onRenderError(error) {
    if (isCancelException(error)) {
      return;
    }
    (0, import_warning5.default)(false, error.toString());
    if (onRenderErrorProps) {
      onRenderErrorProps(error);
    }
  }
  const renderViewport = (0, import_react15.useMemo)(() => page.getViewport({ scale: scale * devicePixelRatio, rotation: rotate }), [devicePixelRatio, page, rotate, scale]);
  const viewport = (0, import_react15.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);
  function drawPageOnCanvas() {
    if (!page) {
      return;
    }
    page.cleanup();
    const { current: canvas } = canvasElement;
    if (!canvas) {
      return;
    }
    canvas.width = renderViewport.width;
    canvas.height = renderViewport.height;
    canvas.style.width = `${Math.floor(viewport.width)}px`;
    canvas.style.height = `${Math.floor(viewport.height)}px`;
    canvas.style.visibility = "hidden";
    const renderContext = {
      annotationMode: renderForms ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE,
      canvasContext: canvas.getContext("2d", { alpha: false }),
      viewport: renderViewport
    };
    if (canvasBackground) {
      renderContext.background = canvasBackground;
    }
    const cancellable = page.render(renderContext);
    const runningTask = cancellable;
    cancellable.promise.then(() => {
      canvas.style.visibility = "";
      onRenderSuccess();
    }).catch(onRenderError);
    return () => cancelRunningTask(runningTask);
  }
  (0, import_react15.useEffect)(
    drawPageOnCanvas,
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      canvasBackground,
      canvasElement,
      devicePixelRatio,
      page,
      renderForms,
      renderViewport,
      viewport
    ]
  );
  const cleanup = (0, import_react15.useCallback)(() => {
    const { current: canvas } = canvasElement;
    if (canvas) {
      canvas.width = 0;
      canvas.height = 0;
    }
  }, [canvasElement]);
  (0, import_react15.useEffect)(() => cleanup, [cleanup]);
  return import_react15.default.createElement("canvas", { className: `${_className}__canvas`, dir: "ltr", ref: mergeRefs(canvasRef, canvasElement), style: {
    display: "block",
    userSelect: "none"
  } }, renderTextLayer ? import_react15.default.createElement(StructTree, null) : null);
}

// node_modules/react-pdf/dist/esm/Page/PageSVG.js
var import_react16 = __toESM(require_react(), 1);
var import_warning6 = __toESM(require_warning(), 1);
function PageSVG() {
  const pageContext = usePageContext();
  invariant(pageContext, "Unable to find Page context.");
  const { _className, onRenderSuccess: onRenderSuccessProps, onRenderError: onRenderErrorProps, page, rotate, scale } = pageContext;
  invariant(page, "Attempted to render page SVG, but no page was specified.");
  const [svgState, svgDispatch] = useResolver();
  const { value: svg, error: svgError } = svgState;
  function onRenderSuccess() {
    if (!page) {
      return;
    }
    if (onRenderSuccessProps) {
      onRenderSuccessProps(makePageCallback(page, scale));
    }
  }
  function onRenderError() {
    if (!svgError) {
      return;
    }
    if (isCancelException(svgError)) {
      return;
    }
    (0, import_warning6.default)(false, svgError.toString());
    if (onRenderErrorProps) {
      onRenderErrorProps(svgError);
    }
  }
  const viewport = (0, import_react16.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);
  function resetSVG() {
    svgDispatch({ type: "RESET" });
  }
  (0, import_react16.useEffect)(resetSVG, [page, svgDispatch, viewport]);
  function renderSVG() {
    if (!page) {
      return;
    }
    const cancellable = makeCancellablePromise(page.getOperatorList());
    cancellable.promise.then((operatorList) => {
      const svgGfx = new pdfjs_default.SVGGraphics(page.commonObjs, page.objs);
      svgGfx.getSVG(operatorList, viewport).then((nextSvg) => {
        if (!(nextSvg instanceof SVGElement)) {
          throw new Error("getSVG returned unexpected result.");
        }
        svgDispatch({ type: "RESOLVE", value: nextSvg });
      }).catch((error) => {
        svgDispatch({ type: "REJECT", error });
      });
    }).catch((error) => {
      svgDispatch({ type: "REJECT", error });
    });
    return () => cancelRunningTask(cancellable);
  }
  (0, import_react16.useEffect)(renderSVG, [page, svgDispatch, viewport]);
  (0, import_react16.useEffect)(
    () => {
      if (svg === void 0) {
        return;
      }
      if (svg === false) {
        onRenderError();
        return;
      }
      onRenderSuccess();
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [svg]
  );
  function drawPageOnContainer(element) {
    if (!element || !svg) {
      return;
    }
    if (!element.firstElementChild) {
      element.appendChild(svg);
    }
    const { width: width2, height: height2 } = viewport;
    svg.setAttribute("width", `${width2}`);
    svg.setAttribute("height", `${height2}`);
  }
  const { width, height } = viewport;
  return import_react16.default.createElement("div", {
    className: `${_className}__svg`,
    // Note: This cannot be shortened, as we need this function to be called with each render.
    ref: (ref) => drawPageOnContainer(ref),
    style: {
      display: "block",
      backgroundColor: "white",
      overflow: "hidden",
      width,
      height,
      userSelect: "none"
    }
  });
}

// node_modules/react-pdf/dist/esm/Page/TextLayer.js
var import_react17 = __toESM(require_react(), 1);
var import_warning7 = __toESM(require_warning(), 1);
function isTextItem(item) {
  return "str" in item;
}
function TextLayer() {
  const pageContext = usePageContext();
  invariant(pageContext, "Unable to find Page context.");
  const { customTextRenderer, onGetTextError, onGetTextSuccess, onRenderTextLayerError, onRenderTextLayerSuccess, page, pageIndex, pageNumber, rotate, scale } = pageContext;
  invariant(page, "Attempted to load page text content, but no page was specified.");
  const [textContentState, textContentDispatch] = useResolver();
  const { value: textContent, error: textContentError } = textContentState;
  const layerElement = (0, import_react17.useRef)(null);
  const endElement = (0, import_react17.useRef)();
  (0, import_warning7.default)(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-text-layer"), 10) === 1, "TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer");
  function onLoadSuccess() {
    if (!textContent) {
      return;
    }
    if (onGetTextSuccess) {
      onGetTextSuccess(textContent);
    }
  }
  function onLoadError() {
    if (!textContentError) {
      return;
    }
    (0, import_warning7.default)(false, textContentError.toString());
    if (onGetTextError) {
      onGetTextError(textContentError);
    }
  }
  function resetTextContent() {
    textContentDispatch({ type: "RESET" });
  }
  (0, import_react17.useEffect)(resetTextContent, [page, textContentDispatch]);
  function loadTextContent() {
    if (!page) {
      return;
    }
    const cancellable = makeCancellablePromise(page.getTextContent());
    const runningTask = cancellable;
    cancellable.promise.then((nextTextContent) => {
      textContentDispatch({ type: "RESOLVE", value: nextTextContent });
    }).catch((error) => {
      textContentDispatch({ type: "REJECT", error });
    });
    return () => cancelRunningTask(runningTask);
  }
  (0, import_react17.useEffect)(loadTextContent, [page, textContentDispatch]);
  (0, import_react17.useEffect)(
    () => {
      if (textContent === void 0) {
        return;
      }
      if (textContent === false) {
        onLoadError();
        return;
      }
      onLoadSuccess();
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [textContent]
  );
  const onRenderSuccess = (0, import_react17.useCallback)(() => {
    if (onRenderTextLayerSuccess) {
      onRenderTextLayerSuccess();
    }
  }, [onRenderTextLayerSuccess]);
  const onRenderError = (0, import_react17.useCallback)((error) => {
    (0, import_warning7.default)(false, error.toString());
    if (onRenderTextLayerError) {
      onRenderTextLayerError(error);
    }
  }, [onRenderTextLayerError]);
  function onMouseDown() {
    const end = endElement.current;
    if (!end) {
      return;
    }
    end.classList.add("active");
  }
  function onMouseUp() {
    const end = endElement.current;
    if (!end) {
      return;
    }
    end.classList.remove("active");
  }
  const viewport = (0, import_react17.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);
  function renderTextLayer() {
    if (!page || !textContent) {
      return;
    }
    const { current: layer } = layerElement;
    if (!layer) {
      return;
    }
    layer.innerHTML = "";
    const textContentSource = page.streamTextContent({ includeMarkedContent: true });
    const parameters = {
      container: layer,
      textContentSource,
      viewport
    };
    const cancellable = pdfjs_default.renderTextLayer(parameters);
    const runningTask = cancellable;
    cancellable.promise.then(() => {
      const end = document.createElement("div");
      end.className = "endOfContent";
      layer.append(end);
      endElement.current = end;
      const layerChildren = layer.querySelectorAll('[role="presentation"]');
      if (customTextRenderer) {
        let index = 0;
        textContent.items.forEach((item, itemIndex) => {
          if (!isTextItem(item)) {
            return;
          }
          const child = layerChildren[index];
          if (!child) {
            return;
          }
          const content = customTextRenderer(Object.assign({
            pageIndex,
            pageNumber,
            itemIndex
          }, item));
          child.innerHTML = content;
          index += item.str && item.hasEOL ? 2 : 1;
        });
      }
      onRenderSuccess();
    }).catch(onRenderError);
    return () => cancelRunningTask(runningTask);
  }
  (0, import_react17.useLayoutEffect)(renderTextLayer, [
    customTextRenderer,
    onRenderError,
    onRenderSuccess,
    page,
    pageIndex,
    pageNumber,
    textContent,
    viewport
  ]);
  return (
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    import_react17.default.createElement("div", { className: clsx_default("react-pdf__Page__textContent", "textLayer"), onMouseUp, onMouseDown, ref: layerElement })
  );
}

// node_modules/react-pdf/dist/esm/Page/AnnotationLayer.js
var import_react18 = __toESM(require_react(), 1);
var import_warning8 = __toESM(require_warning(), 1);
function AnnotationLayer() {
  const documentContext = useDocumentContext();
  const pageContext = usePageContext();
  invariant(pageContext, "Unable to find Page context.");
  const mergedProps = Object.assign(Object.assign({}, documentContext), pageContext);
  const { imageResourcesPath, linkService, onGetAnnotationsError: onGetAnnotationsErrorProps, onGetAnnotationsSuccess: onGetAnnotationsSuccessProps, onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps, onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps, page, pdf, renderForms, rotate, scale = 1 } = mergedProps;
  invariant(pdf, "Attempted to load page annotations, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.");
  invariant(page, "Attempted to load page annotations, but no page was specified.");
  invariant(linkService, "Attempted to load page annotations, but no linkService was specified.");
  const [annotationsState, annotationsDispatch] = useResolver();
  const { value: annotations, error: annotationsError } = annotationsState;
  const layerElement = (0, import_react18.useRef)(null);
  (0, import_warning8.default)(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-annotation-layer"), 10) === 1, "AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations");
  function onLoadSuccess() {
    if (!annotations) {
      return;
    }
    if (onGetAnnotationsSuccessProps) {
      onGetAnnotationsSuccessProps(annotations);
    }
  }
  function onLoadError() {
    if (!annotationsError) {
      return;
    }
    (0, import_warning8.default)(false, annotationsError.toString());
    if (onGetAnnotationsErrorProps) {
      onGetAnnotationsErrorProps(annotationsError);
    }
  }
  function resetAnnotations() {
    annotationsDispatch({ type: "RESET" });
  }
  (0, import_react18.useEffect)(resetAnnotations, [annotationsDispatch, page]);
  function loadAnnotations() {
    if (!page) {
      return;
    }
    const cancellable = makeCancellablePromise(page.getAnnotations());
    const runningTask = cancellable;
    cancellable.promise.then((nextAnnotations) => {
      annotationsDispatch({ type: "RESOLVE", value: nextAnnotations });
    }).catch((error) => {
      annotationsDispatch({ type: "REJECT", error });
    });
    return () => {
      cancelRunningTask(runningTask);
    };
  }
  (0, import_react18.useEffect)(loadAnnotations, [annotationsDispatch, page, renderForms]);
  (0, import_react18.useEffect)(
    () => {
      if (annotations === void 0) {
        return;
      }
      if (annotations === false) {
        onLoadError();
        return;
      }
      onLoadSuccess();
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [annotations]
  );
  function onRenderSuccess() {
    if (onRenderAnnotationLayerSuccessProps) {
      onRenderAnnotationLayerSuccessProps();
    }
  }
  function onRenderError(error) {
    (0, import_warning8.default)(false, `${error}`);
    if (onRenderAnnotationLayerErrorProps) {
      onRenderAnnotationLayerErrorProps(error);
    }
  }
  const viewport = (0, import_react18.useMemo)(() => page.getViewport({ scale, rotation: rotate }), [page, rotate, scale]);
  function renderAnnotationLayer() {
    if (!pdf || !page || !linkService || !annotations) {
      return;
    }
    const { current: layer } = layerElement;
    if (!layer) {
      return;
    }
    const clonedViewport = viewport.clone({ dontFlip: true });
    const annotationLayerParameters = {
      accessibilityManager: null,
      // TODO: Implement this
      annotationCanvasMap: null,
      // TODO: Implement this
      div: layer,
      l10n: null,
      // TODO: Implement this
      page,
      viewport: clonedViewport
    };
    const renderParameters = {
      annotations,
      annotationStorage: pdf.annotationStorage,
      div: layer,
      // See https://github.com/mozilla/pdf.js/issues/17029
      downloadManager: null,
      imageResourcesPath,
      linkService,
      page,
      renderForms,
      viewport: clonedViewport
    };
    layer.innerHTML = "";
    try {
      new pdfjs_default.AnnotationLayer(annotationLayerParameters).render(renderParameters);
      onRenderSuccess();
    } catch (error) {
      onRenderError(error);
    }
    return () => {
    };
  }
  (0, import_react18.useEffect)(
    renderAnnotationLayer,
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [annotations, imageResourcesPath, linkService, page, renderForms, viewport]
  );
  return import_react18.default.createElement("div", { className: clsx_default("react-pdf__Page__annotations", "annotationLayer"), ref: layerElement });
}

// node_modules/react-pdf/dist/esm/Page.js
var __rest4 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var defaultScale = 1;
var Page = function Page2(props) {
  const documentContext = useDocumentContext();
  const mergedProps = Object.assign(Object.assign({}, documentContext), props);
  const { _className = "react-pdf__Page", _enableRegisterUnregisterPage = true, canvasBackground, canvasRef, children, className, customRenderer: CustomRenderer, customTextRenderer, devicePixelRatio, error = "Failed to load the page.", height, inputRef, loading = "Loading pageâ€¦", noData = "No page specified.", onGetAnnotationsError: onGetAnnotationsErrorProps, onGetAnnotationsSuccess: onGetAnnotationsSuccessProps, onGetStructTreeError: onGetStructTreeErrorProps, onGetStructTreeSuccess: onGetStructTreeSuccessProps, onGetTextError: onGetTextErrorProps, onGetTextSuccess: onGetTextSuccessProps, onLoadError: onLoadErrorProps, onLoadSuccess: onLoadSuccessProps, onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps, onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps, onRenderError: onRenderErrorProps, onRenderSuccess: onRenderSuccessProps, onRenderTextLayerError: onRenderTextLayerErrorProps, onRenderTextLayerSuccess: onRenderTextLayerSuccessProps, pageIndex: pageIndexProps, pageNumber: pageNumberProps, pdf, registerPage, renderAnnotationLayer: renderAnnotationLayerProps = true, renderForms = false, renderMode = "canvas", renderTextLayer: renderTextLayerProps = true, rotate: rotateProps, scale: scaleProps = defaultScale, unregisterPage, width } = mergedProps, otherProps = __rest4(mergedProps, ["_className", "_enableRegisterUnregisterPage", "canvasBackground", "canvasRef", "children", "className", "customRenderer", "customTextRenderer", "devicePixelRatio", "error", "height", "inputRef", "loading", "noData", "onGetAnnotationsError", "onGetAnnotationsSuccess", "onGetStructTreeError", "onGetStructTreeSuccess", "onGetTextError", "onGetTextSuccess", "onLoadError", "onLoadSuccess", "onRenderAnnotationLayerError", "onRenderAnnotationLayerSuccess", "onRenderError", "onRenderSuccess", "onRenderTextLayerError", "onRenderTextLayerSuccess", "pageIndex", "pageNumber", "pdf", "registerPage", "renderAnnotationLayer", "renderForms", "renderMode", "renderTextLayer", "rotate", "scale", "unregisterPage", "width"]);
  const [pageState, pageDispatch] = useResolver();
  const { value: page, error: pageError } = pageState;
  const pageElement = (0, import_react19.useRef)(null);
  invariant(pdf, "Attempted to load a page, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop.");
  const pageIndex = isProvided(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;
  const pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : isProvided(pageIndexProps) ? pageIndexProps + 1 : null;
  const rotate = rotateProps !== null && rotateProps !== void 0 ? rotateProps : page ? page.rotate : null;
  const scale = (0, import_react19.useMemo)(() => {
    if (!page) {
      return null;
    }
    let pageScale = 1;
    const scaleWithDefault = scaleProps !== null && scaleProps !== void 0 ? scaleProps : defaultScale;
    if (width || height) {
      const viewport = page.getViewport({ scale: 1, rotation: rotate });
      if (width) {
        pageScale = width / viewport.width;
      } else if (height) {
        pageScale = height / viewport.height;
      }
    }
    return scaleWithDefault * pageScale;
  }, [height, page, rotate, scaleProps, width]);
  function hook() {
    return () => {
      if (!isProvided(pageIndex)) {
        return;
      }
      if (_enableRegisterUnregisterPage && unregisterPage) {
        unregisterPage(pageIndex);
      }
    };
  }
  (0, import_react19.useEffect)(hook, [_enableRegisterUnregisterPage, pdf, pageIndex, unregisterPage]);
  function onLoadSuccess() {
    if (onLoadSuccessProps) {
      if (!page || !scale) {
        return;
      }
      onLoadSuccessProps(makePageCallback(page, scale));
    }
    if (_enableRegisterUnregisterPage && registerPage) {
      if (!isProvided(pageIndex) || !pageElement.current) {
        return;
      }
      registerPage(pageIndex, pageElement.current);
    }
  }
  function onLoadError() {
    if (!pageError) {
      return;
    }
    (0, import_warning9.default)(false, pageError.toString());
    if (onLoadErrorProps) {
      onLoadErrorProps(pageError);
    }
  }
  function resetPage() {
    pageDispatch({ type: "RESET" });
  }
  (0, import_react19.useEffect)(resetPage, [pageDispatch, pdf, pageIndex]);
  function loadPage() {
    if (!pdf || !pageNumber) {
      return;
    }
    const cancellable = makeCancellablePromise(pdf.getPage(pageNumber));
    const runningTask = cancellable;
    cancellable.promise.then((nextPage) => {
      pageDispatch({ type: "RESOLVE", value: nextPage });
    }).catch((error2) => {
      pageDispatch({ type: "REJECT", error: error2 });
    });
    return () => cancelRunningTask(runningTask);
  }
  (0, import_react19.useEffect)(loadPage, [pageDispatch, pdf, pageIndex, pageNumber, registerPage]);
  (0, import_react19.useEffect)(
    () => {
      if (page === void 0) {
        return;
      }
      if (page === false) {
        onLoadError();
        return;
      }
      onLoadSuccess();
    },
    // Ommitted callbacks so they are not called every time they change
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [page, scale]
  );
  const childContext = (0, import_react19.useMemo)(() => (
    // Technically there cannot be page without pageIndex, pageNumber, rotate and scale, but TypeScript doesn't know that
    page && isProvided(pageIndex) && pageNumber && isProvided(rotate) && isProvided(scale) ? {
      _className,
      canvasBackground,
      customTextRenderer,
      devicePixelRatio,
      onGetAnnotationsError: onGetAnnotationsErrorProps,
      onGetAnnotationsSuccess: onGetAnnotationsSuccessProps,
      onGetStructTreeError: onGetStructTreeErrorProps,
      onGetStructTreeSuccess: onGetStructTreeSuccessProps,
      onGetTextError: onGetTextErrorProps,
      onGetTextSuccess: onGetTextSuccessProps,
      onRenderAnnotationLayerError: onRenderAnnotationLayerErrorProps,
      onRenderAnnotationLayerSuccess: onRenderAnnotationLayerSuccessProps,
      onRenderError: onRenderErrorProps,
      onRenderSuccess: onRenderSuccessProps,
      onRenderTextLayerError: onRenderTextLayerErrorProps,
      onRenderTextLayerSuccess: onRenderTextLayerSuccessProps,
      page,
      pageIndex,
      pageNumber,
      renderForms,
      renderTextLayer: renderTextLayerProps,
      rotate,
      scale
    } : null
  ), [
    _className,
    canvasBackground,
    customTextRenderer,
    devicePixelRatio,
    onGetAnnotationsErrorProps,
    onGetAnnotationsSuccessProps,
    onGetStructTreeErrorProps,
    onGetStructTreeSuccessProps,
    onGetTextErrorProps,
    onGetTextSuccessProps,
    onRenderAnnotationLayerErrorProps,
    onRenderAnnotationLayerSuccessProps,
    onRenderErrorProps,
    onRenderSuccessProps,
    onRenderTextLayerErrorProps,
    onRenderTextLayerSuccessProps,
    page,
    pageIndex,
    pageNumber,
    renderForms,
    renderTextLayerProps,
    rotate,
    scale
  ]);
  const eventProps2 = (0, import_react19.useMemo)(() => makeEventProps(otherProps, () => page ? scale ? makePageCallback(page, scale) : void 0 : page), [otherProps, page, scale]);
  const pageKey = `${pageIndex}@${scale}/${rotate}`;
  const pageKeyNoScale = `${pageIndex}/${rotate}`;
  function renderMainLayer() {
    switch (renderMode) {
      case "custom": {
        invariant(CustomRenderer, `renderMode was set to "custom", but no customRenderer was passed.`);
        return import_react19.default.createElement(CustomRenderer, { key: `${pageKey}_custom` });
      }
      case "none":
        return null;
      case "svg":
        return import_react19.default.createElement(PageSVG, { key: `${pageKeyNoScale}_svg` });
      case "canvas":
      default:
        return import_react19.default.createElement(PageCanvas, { key: `${pageKey}_canvas`, canvasRef });
    }
  }
  function renderTextLayer() {
    if (!renderTextLayerProps) {
      return null;
    }
    return import_react19.default.createElement(TextLayer, { key: `${pageKey}_text` });
  }
  function renderAnnotationLayer() {
    if (!renderAnnotationLayerProps) {
      return null;
    }
    return import_react19.default.createElement(AnnotationLayer, { key: `${pageKey}_annotations` });
  }
  function renderChildren() {
    return import_react19.default.createElement(
      PageContext_default.Provider,
      { value: childContext },
      renderMainLayer(),
      renderTextLayer(),
      renderAnnotationLayer(),
      children
    );
  }
  function renderContent() {
    if (!pageNumber) {
      return import_react19.default.createElement(Message, { type: "no-data" }, typeof noData === "function" ? noData() : noData);
    }
    if (pdf === null || page === void 0 || page === null) {
      return import_react19.default.createElement(Message, { type: "loading" }, typeof loading === "function" ? loading() : loading);
    }
    if (pdf === false || page === false) {
      return import_react19.default.createElement(Message, { type: "error" }, typeof error === "function" ? error() : error);
    }
    return renderChildren();
  }
  return import_react19.default.createElement("div", Object.assign({ className: clsx_default(_className, className), "data-page-number": pageNumber, ref: mergeRefs(inputRef, pageElement), style: {
    ["--scale-factor"]: `${scale}`,
    backgroundColor: canvasBackground || "white",
    position: "relative",
    minWidth: "min-content",
    minHeight: "min-content"
  } }, eventProps2), renderContent());
};
var isFunctionOrNode2 = import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.node]);
Page.propTypes = Object.assign(Object.assign({}, eventProps), { canvasBackground: import_prop_types4.default.string, canvasRef: isRef, children: import_prop_types4.default.node, className: isClassName, customRenderer: import_prop_types4.default.func, customTextRenderer: import_prop_types4.default.func, devicePixelRatio: import_prop_types4.default.number, error: isFunctionOrNode2, height: import_prop_types4.default.number, imageResourcesPath: import_prop_types4.default.string, inputRef: isRef, loading: isFunctionOrNode2, noData: isFunctionOrNode2, onGetTextError: import_prop_types4.default.func, onGetTextSuccess: import_prop_types4.default.func, onLoadError: import_prop_types4.default.func, onLoadSuccess: import_prop_types4.default.func, onRenderError: import_prop_types4.default.func, onRenderSuccess: import_prop_types4.default.func, onRenderTextLayerError: import_prop_types4.default.func, onRenderTextLayerSuccess: import_prop_types4.default.func, pageIndex: isPageIndex, pageNumber: isPageNumber, pdf: isPdf, renderAnnotationLayer: import_prop_types4.default.bool, renderForms: import_prop_types4.default.bool, renderMode: isRenderMode, renderTextLayer: import_prop_types4.default.bool, rotate: isRotate, scale: import_prop_types4.default.number, width: import_prop_types4.default.number });
var Page_default = Page;

// node_modules/react-pdf/dist/esm/Thumbnail.js
var import_react20 = __toESM(require_react(), 1);
var __rest5 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Thumbnail = function Thumbnail2(props) {
  const documentContext = useDocumentContext();
  const mergedProps = Object.assign(Object.assign({}, documentContext), props);
  const { className, linkService, onItemClick, pageIndex: pageIndexProps, pageNumber: pageNumberProps, pdf } = mergedProps;
  invariant(pdf, "Attempted to load a thumbnail, but no document was specified. Wrap <Thumbnail /> in a <Document /> or pass explicit `pdf` prop.");
  const pageIndex = isProvided(pageNumberProps) ? pageNumberProps - 1 : pageIndexProps !== null && pageIndexProps !== void 0 ? pageIndexProps : null;
  const pageNumber = pageNumberProps !== null && pageNumberProps !== void 0 ? pageNumberProps : isProvided(pageIndexProps) ? pageIndexProps + 1 : null;
  function onClick(event) {
    event.preventDefault();
    if (!isProvided(pageIndex) || !pageNumber) {
      return;
    }
    invariant(onItemClick || linkService, "Either onItemClick callback or linkService must be defined in order to navigate to an outline item.");
    if (onItemClick) {
      onItemClick({
        pageIndex,
        pageNumber
      });
    } else if (linkService) {
      linkService.goToPage(pageNumber);
    }
  }
  const { className: classNameProps, onItemClick: onItemClickProps } = props, pageProps = __rest5(props, ["className", "onItemClick"]);
  return (
    /* eslint-disable-next-line jsx-a11y/anchor-is-valid */
    import_react20.default.createElement(
      "a",
      { className: clsx_default("react-pdf__Thumbnail", className), href: pageNumber ? "#" : void 0, onClick },
      import_react20.default.createElement(Page_default, Object.assign({}, pageProps, { _className: "react-pdf__Thumbnail__page", _enableRegisterUnregisterPage: false, renderAnnotationLayer: false, renderTextLayer: false }))
    )
  );
};
var Thumbnail_default = Thumbnail;

// node_modules/react-pdf/dist/esm/index.js
displayWorkerWarning();
pdfjs_default.GlobalWorkerOptions.workerSrc = "pdf.worker.js";
export {
  Document_default as Document,
  Outline_default as Outline,
  Page_default as Page,
  PasswordResponses_default as PasswordResponses,
  Thumbnail_default as Thumbnail,
  pdfjs_default as pdfjs,
  useDocumentContext,
  useOutlineContext,
  usePageContext
};
//# sourceMappingURL=react-pdf.js.map
